1
00:00:00,666 --> 00:00:01,700
你在写小部件内

2
00:00:01,700 --> 00:00:04,133
的逻辑时，有没有感到这种满足？

3
00:00:04,133 --> 00:00:07,166
只是因为这就是飘带的设计方式

4
00:00:07,733 --> 00:00:08,933
如果你没有，不要担心

5
00:00:08,933 --> 00:00:10,866
你仍然是一个完全正常的人

6
00:00:11,000 --> 00:00:12,533
而对于那些做了的人

7
00:00:12,533 --> 00:00:13,533
如果我告诉你

8
00:00:13,533 --> 00:00:16,666
你可以吞下一颗蓝色的药丸，让它的大部分都消失。

9
00:00:17,066 --> 00:00:19,200
让我给你介绍一下翩翩起舞的钩子

10
00:00:19,200 --> 00:00:21,400
钩子将解决你的两个主要问题

11
00:00:21,400 --> 00:00:23,133
有状态小组件的模板

12
00:00:23,133 --> 00:00:25,166
并在其状态中共享相同的代码

13
00:00:25,166 --> 00:00:27,100
和处置你的小部件的方法

14
00:00:27,133 --> 00:00:28,133
记得更少一些

15
00:00:28,133 --> 00:00:30,500
你必须花钱编写和维护代码

16
00:00:30,533 --> 00:00:32,300
意味着有更多的时间给你的朋友

17
00:00:32,300 --> 00:00:35,166
家庭或你的女朋友/男朋友

18
00:00:35,166 --> 00:00:36,933
除非你没有任何这些

19
00:00:36,933 --> 00:00:39,500
那么你就应该跳过这个视频

20
00:00:39,566 --> 00:00:41,166
总之，让我们开始吧

21
00:00:41,200 --> 00:00:42,333
进入翩翩酒馆

22
00:00:42,333 --> 00:00:44,900
获取flutter_hooks进入控制台

23
00:00:44,900 --> 00:00:46,666
并等待魔法发挥作用

24
00:00:47,000 --> 00:00:49,100
我答应过你要摆脱模板的。

25
00:00:49,100 --> 00:00:50,500
所以我们先做这个吧

26
00:00:50,500 --> 00:00:53,066
用一个无状态的小组件替换你的有状态小组件

27
00:00:53,066 --> 00:00:54,866
并把它改成一个钩子小部件

28
00:00:55,133 --> 00:00:57,066
如果你以前使用过React钩子的话

29
00:00:57,066 --> 00:00:58,966
你可能就会知道接下来会发生什么了

30
00:00:58,966 --> 00:01:00,666
但对于那些不知道的人来说

31
00:01:00,666 --> 00:01:01,500
忍耐一下吧

32
00:01:01,733 --> 00:01:03,733
钩子是一段可重复使用的代码

33
00:01:03,933 --> 00:01:05,333
你可以写你的钩子

34
00:01:05,333 --> 00:01:06,933
或者使用软件包中许多相当好的钩子之一

35
00:01:06,933 --> 00:01:08,800
1

36
00:01:08,933 --> 00:01:09,800
在任一情况下

37
00:01:09,800 --> 00:01:10,700
有一个规则，

38
00:01:10,700 --> 00:01:13,200
即钩子必须总是以使用为前缀。

39
00:01:13,200 --> 00:01:15,666
并且只在小部件的构建方法中调用

40
00:01:15,966 --> 00:01:18,966
最有用的相当精细的钩子之一是使用效果

41
00:01:18,966 --> 00:01:21,300
它需要一个函数作为第一参数

42
00:01:21,300 --> 00:01:23,066
并让你选择返回另一个函数

43
00:01:23,066 --> 00:01:24,933
作为返回值

44
00:01:25,400 --> 00:01:28,766
第二个参数是一个变量列表，如果改变了这些变量

45
00:01:28,766 --> 00:01:31,333
将导致使用效果钩子再次执行

46
00:01:31,800 --> 00:01:34,000
将第二个参数保留为空数组

47
00:01:34,000 --> 00:01:35,966
将确保冷启动只运行一次

48
00:01:36,166 --> 00:01:38,466
因此，我们在这里所拥有的基本上是它的状态

49
00:01:38,466 --> 00:01:40,733
并在没有通常的繁文缛节的情况下进行了处置

50
00:01:41,000 --> 00:01:43,133
让我们启动应用程序，让自己相信

51
00:01:43,133 --> 00:01:44,466
这是事实

52
00:01:45,166 --> 00:01:47,666
我们也可以让同一个钩子

53
00:01:47,666 --> 00:01:49,166
的多个实例包含不同的代码

54
00:01:49,166 --> 00:01:50,133
这很好

55
00:01:50,400 --> 00:01:52,900
它们都将按照你定义的顺序运行。

56
00:01:52,933 --> 00:01:54,466
钩子是存储在你的小部件中

57
00:01:54,466 --> 00:01:56,166
的列表中的代码片段

58
00:01:56,166 --> 00:01:58,533
但不是与小部件共享相同的状态

59
00:01:58,533 --> 00:02:00,500
它们中的每一个都是独立运行的

60
00:02:00,666 --> 00:02:01,566
因为这个原因

61
00:02:01,566 --> 00:02:04,000
钩子不应该在看到的情况下被调用

62
00:02:04,666 --> 00:02:06,933
最后，让我们看看如果我们

63
00:02:06,933 --> 00:02:09,133
改变第二个参数中列出的变量会发生什么。

64
00:02:09,600 --> 00:02:10,900
注意，其他使用

65
00:02:10,900 --> 00:02:12,766
效果钩子的代码没有被调用

66
00:02:12,766 --> 00:02:15,100
但那个会改变参数的人做到了

67
00:02:15,533 --> 00:02:17,400
现在，你一定在想

68
00:02:17,400 --> 00:02:19,600
使用效果是一个初始化的好地方

69
00:02:19,600 --> 00:02:21,100
并处理我的流

70
00:02:21,133 --> 00:02:22,533
文本编辑控制器

71
00:02:22,533 --> 00:02:24,666
或运行任何初始化代码

72
00:02:24,966 --> 00:02:25,700
那是正确的

73
00:02:25,700 --> 00:02:27,600
但来自翩翩钩子社区的人

74
00:02:27,600 --> 00:02:29,133
谈到这个问题的时候，我想说的是，我已经预见到了，并且创造了

75
00:02:29,133 --> 00:02:31,500
更加专业的钩子，这将使

76
00:02:31,500 --> 00:02:32,466
你的生活更加轻松

77
00:02:32,700 --> 00:02:34,100
另一个你可能会发现很方便的钩子

78
00:02:34,100 --> 00:02:36,600
是使用的文本编辑控制器

79
00:02:36,966 --> 00:02:39,666
文本编辑控制器是那些需要

80
00:02:39,666 --> 00:02:42,100
手动创建和处置的资源之一

81
00:02:42,200 --> 00:02:45,200
但当作为一个钩子处理时，它是自动的

82
00:02:45,700 --> 00:02:48,300
另外，创建一个有状态的小部件的模板

83
00:02:48,300 --> 00:02:49,366
只是为了处理

84
00:02:49,366 --> 00:02:51,066
扩展控制器，这种做法已经消失了。

85
00:02:51,066 --> 00:02:53,133
一切看起来都更加整洁和可读

86
00:02:53,266 --> 00:02:55,800
此外，还有类似控制器的钩子

87
00:02:55,800 --> 00:02:58,000
如 tapController, pageController

88
00:02:58,000 --> 00:02:59,333
和滚动控制器

89
00:02:59,566 --> 00:03:00,266
比如说

90
00:03:00,266 --> 00:03:02,666
如果我们想以编程方式改变步骤

91
00:03:02,666 --> 00:03:03,933
使用步骤控制器

92
00:03:03,933 --> 00:03:04,600
这是我们

93
00:03:04,600 --> 00:03:07,333
必须写下的代码，以使其工作。

94
00:03:07,666 --> 00:03:09,066
我们可以实现同样的事情

95
00:03:09,066 --> 00:03:12,366
使用步骤控制器钩子，代码少得多

96
00:03:12,666 --> 00:03:14,933
在这种情况下，我们需要做一些初始化工作

97
00:03:14,933 --> 00:03:17,000
比如在控制器中添加一个监听器

98
00:03:17,000 --> 00:03:19,100
我们可以在使用效果的钩子里做这件事

99
00:03:19,400 --> 00:03:21,100
我希望这能给你一个想法

100
00:03:21,100 --> 00:03:22,700
钩子如何能一起工作

101
00:03:22,766 --> 00:03:25,000
现在，让我们继续使用状态钩子

102
00:03:25,000 --> 00:03:27,366
使用状态将需要一个通用参数

103
00:03:27,366 --> 00:03:28,766
你的初始状态是什么？

104
00:03:28,933 --> 00:03:32,333
这可以是任何基本类型，但也可以是一个物体

105
00:03:32,466 --> 00:03:33,866
为了简单起见

106
00:03:33,866 --> 00:03:35,266
让我们使用一个布尔状态

107
00:03:35,266 --> 00:03:37,500
这将是一个元素的可见性

108
00:03:37,500 --> 00:03:38,800
当我们点击一个按钮时

109
00:03:39,466 --> 00:03:43,100
让我们运行一个演示，以确保该例子如预期那样工作

110
00:03:43,133 --> 00:03:46,000
点击按钮确实改变了我们的金币状态

111
00:03:46,000 --> 00:03:48,966
而且文本元素的可见度也会改变

112
00:03:48,966 --> 00:03:51,666
使用状态钩是一个值通知器

113
00:03:51,666 --> 00:03:54,533
这意味着我们从值参数中访问它的状态

114
00:03:55,033 --> 00:03:56,166
这工作很好

115
00:03:56,166 --> 00:03:58,400
但是请注意，

116
00:03:58,400 --> 00:03:59,700
我们正在为发生在树中

117
00:03:59,700 --> 00:04:02,100
明显较低位置的东西重建孔部件

118
00:04:02,400 --> 00:04:05,300
我们可以很容易地解决这个问题，

119
00:04:05,366 --> 00:04:08,200
把所有尺寸不足的盒子小部件提取到另一个小部件上

120
00:04:08,300 --> 00:04:11,533
而这是推荐的所谓飘忽不定的方式

121
00:04:11,700 --> 00:04:14,766
但在某些情况下，你可能不希望这样做

122
00:04:14,800 --> 00:04:17,266
或者是当小部件太简单的时候，比如这个小部件

123
00:04:17,266 --> 00:04:19,333
或者为了可读性的缘故

124
00:04:19,666 --> 00:04:22,166
在这种情况下，你可以通过使用一个

125
00:04:22,166 --> 00:04:24,200
叫做hook builder的小部件来隔离被重建的内容

126
00:04:24,400 --> 00:04:26,800
你可以在你的树中的任何地方放置钩子构建器

127
00:04:26,800 --> 00:04:28,966
并从它的构建器方法中给钩子着色

128
00:04:29,300 --> 00:04:31,133
另一种方法来处理这个问题

129
00:04:31,133 --> 00:04:33,400
是通过使用使用值注释来启动一个钩子

130
00:04:33,600 --> 00:04:35,200
这两个钩子的区别是

131
00:04:35,200 --> 00:04:37,733
是，使用状态会立即通知

132
00:04:37,800 --> 00:04:40,300
或重建，而使用

133
00:04:40,366 --> 00:04:42,166
值通知器则不会。

134
00:04:42,600 --> 00:04:45,400
这样我们就可以在顶部的小部件中保持状态参考

135
00:04:45,400 --> 00:04:46,133
并重建

136
00:04:46,133 --> 00:04:48,800
只有那些正在监听它的子部件。

137
00:04:48,866 --> 00:04:52,000
我们可以通过使用value listenable挂钩来监听变化

138
00:04:52,533 --> 00:04:55,100
现在，让我们转到一个更现实的例子

139
00:04:55,133 --> 00:04:57,533
迟早你需要用你的

140
00:04:57,533 --> 00:04:59,000
应用程序访问某种API

141
00:04:59,000 --> 00:05:01,000
并在你的小部件中显示结果

142
00:05:01,200 --> 00:05:03,200
你希望在你的小部件中

143
00:05:03,200 --> 00:05:05,333
放入这样的代码是非常不舒服的。

144
00:05:05,333 --> 00:05:07,733
而不是创建一个单独的类，

145
00:05:07,733 --> 00:05:09,766
以履行关注点分离的原则

146
00:05:10,100 --> 00:05:10,933
一旦你这样做

147
00:05:10,933 --> 00:05:13,166
你需要在你的widget的某个地方调用

148
00:05:13,166 --> 00:05:14,366
这些API函数

149
00:05:14,366 --> 00:05:16,400
就像一个按钮的OnPressed方法

150
00:05:16,733 --> 00:05:18,933
这意味着你需要一个对

151
00:05:18,933 --> 00:05:20,600
顶层小部件上的API类的引用

152
00:05:20,600 --> 00:05:23,166
这可以通过使用记忆化钩子来实现

153
00:05:23,666 --> 00:05:24,800
在使用记忆化钩子中

154
00:05:24,800 --> 00:05:26,866
你可以实例化你的大对象

155
00:05:26,866 --> 00:05:29,666
这将在访问重建之间兑现。

156
00:05:29,933 --> 00:05:31,100
第二个参数

157
00:05:31,100 --> 00:05:32,566
也需要一个值的列表

158
00:05:32,566 --> 00:05:33,366
如果改变

159
00:05:33,366 --> 00:05:35,933
它将迫使新的对象实例被创建。

160
00:05:36,500 --> 00:05:38,733
现在，我们可以使用我们的

161
00:05:38,733 --> 00:05:40,133
API类中的具体方法来获取一些数据了

162
00:05:40,333 --> 00:05:42,200
我们将把它与未来的建造者挂钩

163
00:05:42,200 --> 00:05:44,566
因为这个方法，我们正在调用返回未来

164
00:05:44,900 --> 00:05:45,866
当小组件加载时

165
00:05:45,866 --> 00:05:47,933
我们的API调用的数据也会如此

166
00:05:47,933 --> 00:05:48,800
这很好

167
00:05:49,333 --> 00:05:50,300
如果我们想在

168
00:05:50,300 --> 00:05:52,500
未来的某个时间点获得新鲜的数据怎么办？

169
00:05:52,700 --> 00:05:54,200
我们可以把函数调用

170
00:05:54,200 --> 00:05:55,700
存储到一个值通知器钩中

171
00:05:55,700 --> 00:05:58,000
并将未来的构建器与钩子构建器包裹起来

172
00:05:58,466 --> 00:05:59,866
那些通过调用

173
00:05:59,866 --> 00:06:01,700
gius value listenable 来订阅变化的人

174
00:06:01,700 --> 00:06:03,300
而且每次都有一个变化

175
00:06:03,366 --> 00:06:04,666
就会得到一个新的未来

176
00:06:04,666 --> 00:06:06,266
和最好的未来建设者

177
00:06:06,466 --> 00:06:09,900
通过分配相同的API函数调用到一个值通知器上

178
00:06:09,900 --> 00:06:11,766
我们正在用相同的函数

179
00:06:11,766 --> 00:06:13,966
触发一个重建，但结果不同

180
00:06:13,966 --> 00:06:16,300
如果你认为这是一个有点变化的变通方法来做一些

181
00:06:16,300 --> 00:06:17,766
简单的事情，

182
00:06:17,766 --> 00:06:18,866
比如调用一个函数

183
00:06:18,866 --> 00:06:20,333
你是对的，事情是

184
00:06:20,333 --> 00:06:21,133
扇形钩

185
00:06:21,133 --> 00:06:21,966
并不意味着

186
00:06:21,966 --> 00:06:24,766
默认情况下会成为某种状态管理的解决方案

187
00:06:24,766 --> 00:06:26,566
这个软件包的主要目的是

188
00:06:26,566 --> 00:06:28,066
是为了增加小部件之间

189
00:06:28,066 --> 00:06:30,300
的教练共享，减少模板

190
00:06:30,566 --> 00:06:31,466
因为这个原因

191
00:06:31,466 --> 00:06:34,200
Flutter钩子包经常与河港一起使用

192
00:06:34,200 --> 00:06:34,900
Redux

193
00:06:34,900 --> 00:06:38,200
bloc 或任何其他适当的状态管理包

194
00:06:38,200 --> 00:06:40,500
也有一种方法可以进行状态管理

195
00:06:40,500 --> 00:06:41,566
只能用扑朔迷离的钩子

196
00:06:41,566 --> 00:06:43,900
但这将是未来视频的一个主题

197
00:06:44,333 --> 00:06:47,366
钩子最闪亮的一种情况是动画

198
00:06:47,466 --> 00:06:48,733
到现在为止，

199
00:06:48,733 --> 00:06:50,366
你可能已经发现自己

200
00:06:50,366 --> 00:06:51,966
处于这样一种情况：

201
00:06:51,966 --> 00:06:55,466
你需要一个自定义的动画，而这个动画又不能作为现有的动画部件之一使用。

202
00:06:55,666 --> 00:06:56,333
有了这个

203
00:06:56,333 --> 00:06:58,700
意味着把你以前的无状态小部件

204
00:06:58,700 --> 00:06:59,933
变成一个有状态的小部件

205
00:06:59,933 --> 00:07:02,800
这样你就可以创建和处理动画控制器了。

206
00:07:03,166 --> 00:07:04,966
让我们看看一个

207
00:07:04,966 --> 00:07:07,266
简单的例子，一个带有动画阴影的记录按钮

208
00:07:07,400 --> 00:07:09,833
首先，我们需要定义动画控制器

209
00:07:09,833 --> 00:07:11,933
并设置一些持续时间和方向

210
00:07:12,133 --> 00:07:15,466
我们可以使用memoized钩子来存储动画对象

211
00:07:15,466 --> 00:07:17,766
因为不需要每次都获得一个

212
00:07:17,766 --> 00:07:18,800
新的资源实例。

213
00:07:18,800 --> 00:07:19,866
这是它重建的

214
00:07:20,100 --> 00:07:22,533
最后，我们将定义录音状态

215
00:07:22,933 --> 00:07:25,733
现在，可以将动画分

216
00:07:25,733 --> 00:07:27,200
配给动画生成器和值，以使影子动画化

217
00:07:27,200 --> 00:07:29,600
可以从动画对象中获得

218
00:07:29,600 --> 00:07:31,633
在一个按钮的内部按下方法

219
00:07:31,633 --> 00:07:33,300
将切换录音状态

220
00:07:33,300 --> 00:07:35,933
这将呈现适当的图标和阴影

221
00:07:36,333 --> 00:07:38,366
让我们运行这个游戏，看看它是否有效

222
00:07:38,366 --> 00:07:41,700
点击记录启动动画并显示停止图标

223
00:07:41,700 --> 00:07:43,000
就像预期的那样

224
00:07:43,400 --> 00:07:46,600
点击 "停止 "将删除阴影，并呈现记录按钮

225
00:07:47,066 --> 00:07:49,700
我们可以用另外一个部件来扩展这个例子

226
00:07:49,866 --> 00:07:52,333
让我们假设我们想显示经过的时间

227
00:07:52,333 --> 00:07:54,000
从录音开始

228
00:07:54,066 --> 00:07:56,133
并在停止录制时重置它

229
00:07:56,133 --> 00:07:57,566
以使事情变得更容易阅读

230
00:07:57,566 --> 00:08:00,866
我们将提取按钮部件并创建一个新的

231
00:08:00,866 --> 00:08:01,766
经过时间标签部件

232
00:08:02,133 --> 00:08:05,000
由于这些小部件都将依赖于记录状态

233
00:08:05,000 --> 00:08:07,466
我们可以用钩子构建器部件把它们包在一起

234
00:08:07,566 --> 00:08:10,500
并将状态传递给它们的构造器

235
00:08:10,933 --> 00:08:12,400
经过的时间标签小部件

236
00:08:12,400 --> 00:08:13,566
将由一个简单的

237
00:08:13,566 --> 00:08:15,900
文本小部件组成，并包裹在一个可见性小部件中

238
00:08:16,266 --> 00:08:18,200
我们可以钩住记录状态值

239
00:08:18,200 --> 00:08:19,700
到它的可见性字段

240
00:08:20,166 --> 00:08:22,300
下一件事，我们将需要某种定时器

241
00:08:22,300 --> 00:08:24,866
它将定期更新文本小部件

242
00:08:25,100 --> 00:08:27,400
我们必须记住一件重要的事情，那就是

243
00:08:27,400 --> 00:08:30,000
我们将有大量的自由构建，这取决于我们指定的

244
00:08:30,000 --> 00:08:31,500
定时器周期

245
00:08:31,900 --> 00:08:34,466
我们不希望重建的次数超过

246
00:08:34,466 --> 00:08:37,466
我们设备不能推动的每秒最大帧数

247
00:08:37,466 --> 00:08:39,366
幸运的是，有一种叫做单一股票

248
00:08:39,366 --> 00:08:41,566
提供者的东西解决了这个问题

249
00:08:41,666 --> 00:08:44,000
而且它已经可以作为一个建筑钩子了

250
00:08:44,333 --> 00:08:46,833
下一步，我们需要创建一个实际的ticker对象

251
00:08:46,833 --> 00:08:48,533
这将使用一个贴纸提供者

252
00:08:48,533 --> 00:08:49,500
一个粘性源

253
00:08:49,500 --> 00:08:50,700
和更新状态

254
00:08:50,733 --> 00:08:52,366
在每一帧的时间结束后

255
00:08:52,366 --> 00:08:54,000
现在，我们有了一个股票对象

256
00:08:54,000 --> 00:08:55,766
我们还需要让它坚持下去

257
00:08:55,900 --> 00:08:57,900
我们可以在使用效果钩中做到这一点

258
00:08:58,133 --> 00:09:00,766
我们还得确保所有这些重新运行的

259
00:09:00,766 --> 00:09:04,366
值添加到使用效果钩子的依赖列表中，

260
00:09:04,366 --> 00:09:06,933
以确保在记录状态改变后重新运行。

261
00:09:07,400 --> 00:09:09,900
该贴纸最终也应被处理掉

262
00:09:10,000 --> 00:09:12,000
所以我们将需要另一个使用效果钩

263
00:09:12,000 --> 00:09:15,466
并确保它只运行一次，而且只由自己处理。

264
00:09:15,866 --> 00:09:17,700
现在我们已经准备好了所有的资源

265
00:09:17,700 --> 00:09:20,900
所以，让我们把状态封锁给文本部件，并运行这个例子

266
00:09:21,166 --> 00:09:22,566
你可能已经注意到

267
00:09:22,566 --> 00:09:25,500
我们不得不多写一点代码来使这一切正常进行

268
00:09:25,500 --> 00:09:27,666
这使得我们的小部件充满了逻辑

269
00:09:27,933 --> 00:09:29,266
我们想做的最后一件事是

270
00:09:29,266 --> 00:09:31,466
违背了我们在战斗中使用飘带钩的

271
00:09:31,466 --> 00:09:32,733
所有原则

272
00:09:32,800 --> 00:09:34,300
但不要害怕，我的朋友们

273
00:09:34,300 --> 00:09:36,666
因为我们可以将所有的逻辑提取到

274
00:09:36,700 --> 00:09:38,800
一个单独的文件中的自定义钩子中。

275
00:09:39,300 --> 00:09:41,466
创建一个自定义钩子再简单不过了

276
00:09:41,466 --> 00:09:43,333
你所要做的就是创建一个函数

277
00:09:43,333 --> 00:09:45,266
并复制出它里面的逻辑

278
00:09:45,600 --> 00:09:47,866
确保你的钩子名称以我们开头

279
00:09:47,866 --> 00:09:50,200
并返回你感兴趣的资源

280
00:09:50,200 --> 00:09:52,333
在这种情况下，我们将返回持续时间

281
00:09:52,333 --> 00:09:55,366
现在，我们可以用一行来替换我们

282
00:09:55,366 --> 00:09:56,600
在 widget build 方法中的所有代码

283
00:09:56,966 --> 00:09:58,500
另外，如果你需要的话，

284
00:09:58,500 --> 00:10:00,266
你可以在任何其他小部件中使用这个钩子

285
00:10:00,733 --> 00:10:02,166
就这样吧，伙计们

286
00:10:02,266 --> 00:10:03,333
享受你美好的一天
